#+TITLE: Model Checking from first principles
#+Author: Alistair Johnston
#+PROPERTY: header-args :tangle CTL.hs
#+auto_tangle: t
#+STARTUP: showeverything latexpreview
#+OPTIONS: toc:2 tex:t

* File Header
#+BEGIN_SRC haskell
module CTL(module CTL) where

import Data.Matrix (Matrix, fromLists, getCol, getRow, prettyMatrix, nrows, ncols)
import Data.Vector (Vector, toList)
import Data.List (nub, findIndices, elem)
import Data.Bool

import Control.Parallel.Strategies
#+END_SRC

* Prerequisites to Model Checking
Before we start to write a model checker we must first define some prerequisites:

** Labelling Function
A labelling function is what gives us which states satisfy $\Phi$, i.e. this is how we check $Sat(\Phi)$
In terms of code it is sufficient to have a list of Boolean values which each map to a state.

For example say we have states $s_0, s_1, s_2$ and $\Phi$ is defined as True if the state is even else Odd, then we can represent $Sat(\Phi)$ as:
#+BEGIN_SRC haskell
--satPhi :: [Bool]
--satPhi = [True, False, True]
#+END_SRC

** Transition Systems
A Transition System is the definition of which states are able to be reached from other states; this is effectively a graph representation of the state-space.

For our use case it suffices to simply use an adjacency matrix defined as such:
#+BEGIN_SRC haskell
--matrix :: Matrix Bool
matrix = fromLists [[False, True, True], [False, False, True], [False, False, False]]
ts = fromLists [[False, True], [False, False]]
#+END_SRC

Additionally we need methods to check the set of states that we can reach from our current state, in an adjacency matrix we have:
Predecessor(state) = column at state index
Successor(state) = row at state index

Which we can represent as such:
#+BEGIN_SRC haskell
pre :: Matrix a -> Int -> [a]
pre m n = toList $ getCol (n+1) m

post :: Matrix a -> Int -> [a] 
post m n = toList $ getRow (n+1) m
#+END_SRC

* CTL Model Checking
We start with CTL Model checking as the algorithms to perform CTL model checking are simpler than those used for other logic systems.

It is sufficient for CTL model checking algorithms to be able to handle six cases:
 - $true$
 - $ap$
 - $\Phi_1 \wedge \Phi_2$
 - $\neg \Psi$
 - $\exists \textbf{X} \Psi$ - There exists some next timestep which satisfies $f_1$.
 - $\exists (\Phi U \Psi)$ - There exists some path where $Sat(\Phi)$ until $Sat(\Psi)$
 - $\exists \Box \Phi$ - There exists a path where $\Phi$ is always satisfied.

** CTL logic formulae
First we need to define a CTL logic formula
#+BEGIN_SRC haskell
data CTLFormula =
    Satisfaction [Bool]
  | Atomic [Bool]
  | And CTLFormula CTLFormula
  | Not CTLFormula
  | ExistsNext CTLFormula
  | ExistsPhiUntilPsi CTLFormula CTLFormula
  | ExistsAlwaysPhi CTLFormula
  | ForAllNextPhi CTLFormula
  | ForAllPhiUntilPsi CTLFormula CTLFormula
  | ForAllEventuallyPhi CTLFormula
  | ForAllAlwaysPhi CTLFormula
    deriving (Eq, Show)

#+END_SRC

Additionally we need some way of evaluating these formulae to a boolean
#+BEGIN_SRC haskell
evaluateCTL :: CTLFormula -> Matrix Bool -> [Bool]
evaluateCTL (Satisfaction satisfy) _ = satisfy
evaluateCTL (Atomic satisfy) _ = satisfy
evaluateCTL (And phi psi) m = zipWith (&&) (evaluateCTL phi m) (evaluateCTL psi m)
evaluateCTL (Not phi) m = map not (evaluateCTL phi m)
evaluateCTL (ExistsNext phi) m = existsNextPhi m (evaluateCTL phi m)
evaluateCTL (ExistsPhiUntilPsi phi psi) m = existsPhiUntilPsi m (evaluateCTL phi m) (evaluateCTL psi m)
evaluateCTL (ExistsAlwaysPhi phi) m = existsAlwaysPhi m (evaluateCTL phi m)

evaluateCTL (ForAllNextPhi phi) m = map not (existsNextPhi m notPhi)
  where
    notPhi = map not (evaluateCTL phi m)

evaluateCTL (ForAllPhiUntilPsi phi psi) m = zipWith (&&) doesNotExistCombo doesNotExistNotPsi
  where 
    notPhi = map not (evaluateCTL phi m)
    notPsi = map not (evaluateCTL psi m)
    notPhiAndNotPsi = zipWith (&&) notPhi notPsi
    doesNotExistNotPsi = map not (existsAlwaysPhi m notPsi)
    doesNotExistCombo = map not (existsPhiUntilPsi m notPsi notPhiAndNotPsi)
    

evaluateCTL (ForAllEventuallyPhi phi) m = map not (existsAlwaysPhi m notPhi)
  where
    notPhi = map not (evaluateCTL phi m)

evaluateCTL (ForAllAlwaysPhi phi) m = map not (existsPhiUntilPsi m true notPhi)
  where
    notPhi = map not (evaluateCTL phi m)
    true = replicate (nrows m) True 

predicateAnd :: [Bool] -> [Bool] -> [Bool]
predicateAnd satPhi satPsi = [(satPhi !! x) && (satPsi !! x) | x <- [0..length satPhi - 1]]

existsNextPhi :: Matrix Bool -> [Bool] -> [Bool]
existsNextPhi matrix satisfy = stepByFunc satisfy [True | _ <- [0.. length satisfy -1]] matrix pre
#+END_SRC

** There exists some path where $\Phi$ is satisfied until $\Psi$
The simplest case to check (past the trivial cases) is the case where we are interested in $Sat(\exists(\Phi U \Psi))$.
In this case we are given:
 - The labelling functions: $Sat(\Phi)$ and $Sat(\Psi)$
 -	A transition system TS
 -	A set of states S

The approach outlined in Principles of Model checking p351 involved making a choice of elements in the visited set of states and then extending it,
however a simpler approach is to extend the set of states that we can reach by 1 timestep at each iteration, that is we apply pre to our set of reachable sets
at each repetition.

#+BEGIN_SRC haskell
--satPsi :: [Bool]
--satPsi = [False, False, True]
#+END_SRC

#+BEGIN_SRC haskell
extendBy :: [Bool] -> (Matrix Bool -> Int -> [Bool]) -> Matrix Bool -> [Int]
extendBy prior step m = posterior
  where
    vertices = findIndices id prior
    vertices' = map (step m) vertices `using` parBuffer 1 rseq
    posterior = nub $ [ vv | uu <- map (findIndices id) vertices', vv <- uu]
#+END_SRC

In our previous transition system we can see that there are two paths that satisfy $\exists(\Phi U \Psi)$: namely the paths $s_0 \rightarrow s_2$ and $s_2$ 
#+BEGIN_SRC haskell
stepByFunc :: [Bool] -> [Bool] -> Matrix Bool -> (Matrix Bool -> Int -> [Bool]) -> [Bool]
stepByFunc [] _ _ _ = []
stepByFunc prior labelling m step = posterior
  where
--States we can reach
    vertices  = extendBy prior step m
--Filter to states where the predicate is true
    reachable = filter (labelling !!) vertices
    posterior = [x `elem` reachable | x <- [0..length prior - 1]]

existsPhiUntilPsi :: Matrix Bool -> [Bool] -> [Bool] -> [Bool]
existsPhiUntilPsi matrix [] satisfy = satisfy
existsPhiUntilPsi matrix satPhi [] = []
existsPhiUntilPsi matrix satPhi satisfy =
  if satisfy' == satisfy
    then satisfy
    else existsPhiUntilPsi matrix satPhi satisfy'
  where
    nextStep = stepByFunc satisfy satPhi matrix pre
    satisfy' = zipWith (||) satisfy nextStep
#+END_SRC

* $\exists \Box \Phi$
Start with all states where $Sat(\Phi)$, repeatedly recurse (stepping back in the graph) until we get either a repeat or empty set (as before)
At each iteration we get Just the result of the backward step (as opposed to $\exists \Phi U \Psi$ where we took the union of the prior and posterior)
If we get a repeat then True if empty then False

#+BEGIN_SRC haskell
existsAlwaysPhi :: Matrix Bool -> [Bool] -> [Bool]
existsAlwaysPhi matrix [] = []
existsAlwaysPhi matrix satisfy =
  if satisfy' == satisfy
    then satisfy
    else existsAlwaysPhi matrix satisfy'
  where
    nextStep = stepByFunc satisfy satisfy matrix pre
    satisfy' = zipWith (&&) satisfy nextStep
#+END_SRC

